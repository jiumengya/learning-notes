## 3.1、自定义泛型类举例

> 1、OrderTest类

```java
/**
 * 自定义泛型类
 *
 */
public class OrderTest<T> { 

    String orderName;
    int orderId;

    //类的内部结构就可以使用类的泛型
    T orderT;

    public OrderTest(){ 

    };

    public OrderTest(String orderName,int orderId,T orderT){ 
        this.orderName = orderName;
        this.orderId = orderId;
        this.orderT = orderT;
    }

    //如下的三个方法都不是泛型方法
    public T getOrderT(){ 
        return orderT;
    }

    public void setOrderT(T orderT){ 
        this.orderT = orderT;
    }

    @Override
    public String toString() { 
        return "Order{" +
                "orderName='" + orderName + '\'' +
                ", orderId=" + orderId +
                ", orderT=" + orderT +
                '}';
    }
  
    //泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。
    //换句话说，泛型方法所属的类是不是泛型类都没有关系。
    //泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。
    public static <E>  List<E> copyFromArrayToList(E[] arr){ 

        ArrayList<E> list = new ArrayList<>();

        for(E e : arr){ 
            list.add(e);
        }
        return list;

    }
}
```

> 2、SubOrder类

```java
public class SubOrder extends OrderTest<Integer>{    //SubOrder:不是泛型类
}
12
```

> 3、SubOrder1类

```java
public class SubOrder1<T> extends OrderTest<T> { //SubOrder1<T>:仍然是泛型类
}
```

> 4、GenericTest1类

```java
import org.junit.Test;

/**
 * 如何自定义泛型结构：泛型类、泛型接口；泛型方法。
 *
 * 1.关于自定义泛型类、泛型接口：
 */
public class GenericTest1 { 

    @Test
    public void test(){ 
        /**
         * 如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object类型
         * 要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。
         */
        OrderTest order = new OrderTest();
        order.setOrderT(123);
        order.setOrderT("ABC");

        //建议：实例化时指明类的泛型
        OrderTest<String> order1 = new OrderTest<String>("orderAA",1001,"order:AA");

        order1.setOrderT("AA:hello");
    }

    @Test
    public void test2(){ 
        SubOrder sub1 = new SubOrder();
        //由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型。
        sub1.setOrderT(1122);

        SubOrder1<String> sub2 = new SubOrder1<>();
        sub2.setOrderT("order2...");
    }
}
```

## 3.2、自定义泛型类泛型接口的注意点

**注意点：**

1. **泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：<E1,E2,E3>**
2. 泛型类的构造器如下：public GenericClass(){}。而下面是错误的：public GenericClass(){}
3. 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。
4. 泛型不同的引用不能相互赋值。尽管在编译时ArrayList和ArrayList是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。
5. 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。 经验：泛型要使用一路都用。要不用，一路都不要用。
6. 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。
7. jdk1.7，泛型的简化操作：ArrayList flist = new ArrayList<>();
8. **泛型的指定中不能使用基本数据类型，可以使用包装类替换。**
9. **在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。**
10. **异常类不能是泛型的** `java //异常类不能声明为泛型类 //public class MyException<T> extends Exception{  //} 123 `

**代码演示：**

不能使用`new E[]`。但是可以：`E[] elements = (E[])new Object[capacity]`;参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。

> 1、Person类

```java
public class Person { 
}
```

> 2、OrderTest类

```java
/**
 * 自定义泛型类
 */
public class OrderTest<T> { 

    String orderName;
    int orderId;

    //类的内部结构就可以使用类的泛型
    T orderT;

    public OrderTest(){ 
        //编译不通过
//        T[] arr = new T[10];
        //编译通过
        T[] arr = (T[]) new Object[10];
    };

    public OrderTest(String orderName,int orderId,T orderT){ 
        this.orderName = orderName;
        this.orderId = orderId;
        this.orderT = orderT;
    }

    public T getOrderT(){ 
        return orderT;
    }

    public void setOrderT(T orderT){ 
        this.orderT = orderT;
    }

    @Override
    public String toString() { 
        return "Order{" +
                "orderName='" + orderName + '\'' +
                ", orderId=" + orderId +
                ", orderT=" + orderT +
                '}';
    }

    //静态方法中不能使用类的泛型。
//    public static void show(T orderT){ 
//        System.out.println(orderT);
//    }

    public void show(){ 
        //编译不通过
//        try{ 
//
//
//        }catch(T t){ 
//
//        }
    }
}
```

> 3、GenericTest1类

```java
import org.junit.Test;

import java.util.ArrayList;

/**
 * 如何自定义泛型结构：泛型类、泛型接口；泛型方法。
 *
 * 1.关于自定义泛型类、泛型接口：
 *
 */
public class GenericTest1 { 

    @Test
    public void test3(){ 
        ArrayList<String> list1 = null;
        ArrayList<Integer> list2 = new ArrayList<Integer>();
        //泛型不同的引用不能相互赋值。
        //list1 = list2;

        Person p1 = null;
        Person p2 = null;
        p1 = p2;
    }
}
```

> 4、在继承中使用泛型

1. 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：
   - 子类不保留父类的泛型：按需实现
     - 没有类型擦除
     - 具体类型
   - 子类保留父类的泛型：泛型子类
     - 全部保留
     - 部分保留

```java
class Father<T1, T2> { }
// 子类不保留父类的泛型
// 1)没有类型擦除
class Son1 extends Father { // 等价于class Son extends Father<Object,Object>{}
}
// 2)具体类型
class Son2 extends Father<Integer, String> { }
// 子类保留父类的泛型
// 1)全部保留
class Son3<T1, T2> extends Father<T1, T2> { }
// 2)部分保留
class Son4<T2> extends Father<Integer, T2> { }
```

**结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型。**

## 3.3、自定义泛型方法举例

**说明：**

- 方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。
- 泛型方法的格式： `[访问权限] <泛型> 返回类型  方法名([泛型标识参数名称]) 抛出的异常 如：public static <E>  List<E> copyFromArrayToList(E[] arr)　throws  Exception{  } 12`

**代码演示：**

> 1、OrderTest类

```java
import java.util.ArrayList;
import java.util.List;

/**
 * 自定义泛型类
 */
public class OrderTest<T> { 

    /**
     * 泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。
     * 换句话说，泛型方法所属的类是不是泛型类都没有关系。
     * 泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。
     */
    public static <E> List<E> copyFromArrayToList(E[] arr){ 

        ArrayList<E> list = new ArrayList<>();

        for(E e : arr){ 
            list.add(e);
        }
        return list;

    }
}
```

> 2、测试类

```java
import org.junit.Test;

import java.util.ArrayList;
import java.util.List;

/**
 * 如何自定义泛型结构：泛型类、泛型接口；泛型方法。
 *
 * 1.关于自定义泛型类、泛型接口：
 *
 */
public class GenericTest1 { 

    //测试泛型方法
    @Test
    public void test4(){ 
        OrderTest<String> order = new OrderTest<>();
        Integer[] arr = new Integer[]{ 1,2,3,4};
        //泛型方法在调用时，指明泛型参数的类型。
        List<Integer> list = order.copyFromArrayToList(arr);

        System.out.println(list);
    }
}
```

> 3、SubOrder类

```java
import java.util.ArrayList;
import java.util.List;

public class SubOrder extends OrderTest<Integer>{    //SubOrder:不是泛型类
  
    public static <E> List<E> copyFromArrayToList(E[] arr){ //静态的泛型方法

        ArrayList<E> list = new ArrayList<>();

        for(E e : arr){ 
            list.add(e);
        }
        return list;

    }
}
```

## 3.4、举例泛型类和泛型方法的使用情境

> 1、DAO类

```java
import java.util.List;

public class DAO<T> {  //表的共性操作的DAO

    //添加一条记录
    public void add(T t){ 

    }

    //删除一条记录
    public boolean remove(int index){ 

        return false;
    }

    //修改一条记录
    public void update(int index,T t){ 

    }

    //查询一条记录
    public T getIndex(int index){ 

        return null;
    }

    //查询多条记录
    public List<T> getForList(int index){ 

        return null;
    }

    //泛型方法
    //举例：获取表中一共有多少条记录？获取最大的员工入职时间？
    public <E> E getValue(){ 

        return null;
    }

}
```

> 2、Customer类

```java
public class Customer {  //此类对应数据库中的customers表
}
```

> 3、CustomerDAO类

```java
public class CustomerDAO extends DAO<Customer>{ //只能操作某一个表的DAO
}
```

> 4、Student类

```java
public class Student { 
}
```

> 5、StudentDAO类

```java
public class StudentDAO extends DAO<Student> { //只能操作某一个表的DAO
}
```

> 6、DAOTest类

```java
import org.junit.Test;

import java.util.List;

public class DAOTest { 

    @Test
    public void test(){ 
        CustomerDAO dao1 = new CustomerDAO();

        dao1.add(new Customer());
        List<Customer> list = dao1.getForList(10);


        StudentDAO dao2 = new StudentDAO();
        Student student = dao2.getIndex(1);
    }

}
```