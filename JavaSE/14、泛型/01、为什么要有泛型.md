泛型：标签

## 1.1、举例

- 中药店，每个抽屉外面贴着标签
- 超市购物架上很多瓶子，每个瓶子装的是什么，有标签。

## 1.2、泛型的设计背景

[集合](https://so.csdn.net/so/search?q=集合&spm=1001.2101.3001.7020)容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以 **在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决** 。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时 **把元素的类型设计成一个参数，这个类型参数叫做泛型** 。Collection，List，ArrayList这个就是类型参数，即泛型。

## 1.3、其他说明

- 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。
- 从JDK1.5以后，Java引入了“参数化类型（Parameterizedtype）”的概念，允许我们在创建集合时再指定集合元素的类型，正如：List，这表明该List只能保存字符串类型的对象。
- JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参。

## 1.3、那么为什么要有泛型呢

**那么为什么要有泛型呢，直接Object不是也可以存储数据吗？**

> **1、解决元素存储的安全性问题，好比商品、药品标签，不会弄错。2.解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。**



![img](./assets/image.png)



![img](./assets/image-1668759829012-1.png)

> **2、Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。**

```java
import org.junit.Test;

import java.util.ArrayList;

/**
 * 泛型的使用
 * 1.jdk5.0新增的特征
 */
public class GenericTest { 

    //在集合中使用泛型之前的情况：
    @Test
    public void test(){ 
        ArrayList list = new ArrayList();
        //需求：存放学生的成绩
        list.add(78);
        list.add(49);
        list.add(72);
        list.add(81);
        list.add(89);
        //问题一：类型不安全
//        list.add("Tom");

        for(Object score : list){ 
            //问题二：强转时可能出现类型转化异常
            int stuScore = (Integer)score;

            System.out.println(stuScore);
        }

    }

}
```